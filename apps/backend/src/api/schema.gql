# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type Album {
  artists: [Artist!]!

  """
  Dark muted color from cover art (hex string)
  """
  coverColorDarkMuted: String!

  """
  Dark vibrant color from cover art (hex string)
  """
  coverColorDarkVibrant: String!

  """
  Light muted color from cover art (hex string)
  """
  coverColorLightMuted: String!

  """
  Light vibrant color from cover art (hex string)
  """
  coverColorLightVibrant: String!

  """
  Muted color from cover art (hex string)
  """
  coverColorMuted: String!

  """
  Vibrant color from cover art (hex string)
  """
  coverColorVibrant: String!
  date: DateTime
  id: String!
  name: String!

  """
  Tracks grouped by disc number, ordered by track number
  """
  tracksByDisc: [[Track!]!]!
}

type AlbumBasic {
  artists: [Artist!]!

  """
  Dark muted color from cover art (hex string)
  """
  coverColorDarkMuted: String!

  """
  Dark vibrant color from cover art (hex string)
  """
  coverColorDarkVibrant: String!

  """
  Light muted color from cover art (hex string)
  """
  coverColorLightMuted: String!

  """
  Light vibrant color from cover art (hex string)
  """
  coverColorLightVibrant: String!

  """
  Muted color from cover art (hex string)
  """
  coverColorMuted: String!

  """
  Vibrant color from cover art (hex string)
  """
  coverColorVibrant: String!
  date: DateTime
  id: String!
  name: String!
}

type Artist {
  id: String!
  name: String!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

type IndexingErrorMetaflacParsing {
  errorMessage: String!
  filePath: String!
  type: IndexingReportType!
}

type IndexingJob {
  completedAt: DateTime
  error: String
  jobId: String!
  progress: Float
  status: IndexingJobStatus!
  warnings: [IndexingWarning!]
}

enum IndexingJobStatus {
  ACTIVE
  COMPLETED
  FAILED
  QUEUED
}

enum IndexingReportType {
  ERROR_LYRICS_PARSING
  ERROR_METAFLAC_PARSING
  WARNING_FOLDER_METADATA
  WARNING_SUBDIRECTORIES
}

union IndexingWarning =
  | IndexingErrorMetaflacParsing
  | IndexingWarningFolderMetadata
  | IndexingWarningSubdirectories

type IndexingWarningFolderMetadata {
  folderPath: String!
  messages: [String!]!
  type: IndexingReportType!
}

type IndexingWarningSubdirectories {
  dirPath: String!
  type: IndexingReportType!
}

type LyricsChunk {
  """
  Word or character
  """
  c: String!

  """
  Duration in milliseconds since the start of the line
  """
  d: Int!
}

type LyricsLine {
  """
  Tokenized line content (word/character + duration)
  """
  l: [LyricsChunk!]!

  """
  Full text of the line
  """
  t: String!

  """
  Timestamp end in milliseconds
  """
  te: Int!

  """
  Timestamp start in milliseconds
  """
  ts: Int!
}

type Mutation {
  """
  Update a user profile as an administrator
  """
  adminUpdateUserProfile(input: UpdateUserProfileInput!, userId: String!): User!

  """
  Trigger a new library indexing job
  """
  triggerIndexing: IndexingJob!

  """
  Update the current user's profile
  """
  updateMyProfile(input: UpdateUserProfileInput!): User!
}

type Query {
  """
  Get a single album by ID with tracks grouped by disc number
  """
  album(id: String!): Album!

  """
  Get a single artist by ID
  """
  artist(id: String!): Artist!
  hello: String!

  """
  Get the status of an indexing job
  """
  indexingJobStatus(jobId: String!): IndexingJob!

  """
  Current logged-in user
  """
  me: User!

  """
  Search across tracks, albums, and artists with flexible filtering. Returns matching results for all entity types. Note: limit applies to each entity type separately.
  """
  search(input: SearchMusicInput!): SearchMusicResult!

  """
  Search for albums with optional filters. Use this to get all albums by an artist.
  """
  searchAlbums(input: SearchAlbumsInput!): [Album!]!

  """
  Search for artists with optional filters
  """
  searchArtists(input: SearchArtistsInput!): [Artist!]!

  """
  Search for tracks with optional filters
  """
  searchTracks(input: SearchTracksInput!): [Track!]!

  """
  Get a single track by ID
  """
  track(id: String!): Track!

  """
  User profile by identifier (admin access only)
  """
  userProfile(userId: String!): User!
}

enum Role {
  ADMIN
  USER
}

input SearchAlbumsInput {
  """
  Filter by artist ID
  """
  artistId: String

  """
  Maximum number of results
  """
  limit: Int = 50

  """
  Filter by album name (case-insensitive partial match)
  """
  name: String

  """
  Number of results to skip
  """
  offset: Int = 0
}

input SearchArtistsInput {
  """
  Maximum number of results
  """
  limit: Int = 50

  """
  Filter by artist name (case-insensitive partial match)
  """
  name: String

  """
  Number of results to skip
  """
  offset: Int = 0
}

input SearchMusicInput {
  """
  Filter by exact album ID
  """
  albumId: String

  """
  Filter by album name (case-insensitive partial match)
  """
  albumName: String

  """
  Filter by exact artist ID
  """
  artistId: String

  """
  Filter by artist name (case-insensitive partial match)
  """
  artistName: String

  """
  Include albums in search results
  """
  includeAlbums: Boolean = true

  """
  Include artists in search results
  """
  includeArtists: Boolean = true

  """
  Include tracks in search results
  """
  includeTracks: Boolean = true

  """
  Maximum number of results to return
  """
  limit: Int = 50

  """
  Number of results to skip
  """
  offset: Int = 0

  """
  Filter by track name (case-insensitive partial match)
  """
  trackName: String
}

type SearchMusicResult {
  albums: [Album!]!
  artists: [Artist!]!
  tracks: [Track!]!
}

input SearchTracksInput {
  """
  Filter by album ID
  """
  albumId: String

  """
  Filter by artist ID
  """
  artistId: String

  """
  Maximum number of results
  """
  limit: Int = 50

  """
  Filter by track name (case-insensitive partial match)
  """
  name: String

  """
  Number of results to skip
  """
  offset: Int = 0
}

enum Sex {
  XX
  XY
}

type Subscription {
  """
  Subscribe to indexing job status updates
  """
  indexingJobUpdated(jobId: String!): IndexingJob!
}

type Track {
  """
  Album metadata
  """
  album: AlbumBasic
  albumId: String
  artists: [Artist!]!
  date: DateTime
  discNumber: Int!

  """
  Duration in milliseconds
  """
  durationMs: Int!

  """
  Linked FLAC file id if present
  """
  flacFileId: String

  """
  Whether the track has lyrics indexed
  """
  hasLyrics: Boolean!
  id: String!
  isrc: String

  """
  Optional lyrics data associated with the track
  """
  lyrics: [LyricsLine!]
  name: String!
  trackNumber: Int!
}

input UpdateUserProfileInput {
  """
  User sex chosen during profile setup
  """
  sex: Sex
}

type User {
  createdAt: DateTime!
  id: String!
  oidcSub: String!
  role: Role!
  sex: Sex
  updatedAt: DateTime!
  username: String!
}
