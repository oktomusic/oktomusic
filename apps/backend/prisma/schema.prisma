generator client {
  provider     = "prisma-client"
  output       = "../src/generated/prisma"
  moduleFormat = "cjs"
}

datasource db {
  provider = "postgresql"
}

// ---------------------------------------
// User profiles
// ---------------------------------------

enum Role {
  USER
  ADMIN
}

enum Sex {
  XY
  XX
}

model User {
  id        String   @id @default(cuid())
  username  String   @unique
  oidcSub   String   @unique // OIDC "sub" claim
  role      Role     @default(USER)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  sex       Sex? // NULL if not specified

  @@index([username])
  @@index([role])
  @@index([sex])
}

// ---------------------------------------
// Primary Music Model
// ---------------------------------------

model Track {
  // Track metadata
  id         String    @id @default(cuid())
  name       String
  isrc       String?
  date       DateTime? @db.Date
  durationMs Int

  artists TrackArtist[]

  // Album relation
  album       Album?  @relation(fields: [albumId], references: [id])
  albumId     String?
  // Ordering within album
  discNumber  Int
  trackNumber Int

  // Source file (0..1)
  flacFile FlacFile?

  @@unique([albumId, discNumber, trackNumber])
  @@index([albumId])
  @@index([albumId, discNumber, trackNumber])
}

model FlacFile {
  id String @id @default(cuid())

  /**
   * Relative path from the library root (stable identifier for a file).
   */
  relativePath String @unique

  // Extracted ffprobe info
  sampleRate       Int
  bitsPerRawSample Int
  durationMs       Int
  fileSize         Int
  bitRate          Int

  // Required: a flac file cannot exist without an attached track
  trackId String @unique
  track   Track  @relation(fields: [trackId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Track -> Album -> many-to-one
// Album -> Track -> one-to-many
// Album -> Artist -> many-to-many
// Artist -> Track -> many-to-many

model Album {
  id      String        @id @default(cuid())
  name    String
  date    DateTime?     @db.Date
  artists AlbumArtist[]
  tracks  Track[]
}

model Artist {
  id           String        @id @default(cuid())
  name         String        @unique // Potentially fragile, but acceptable for now
  tracks       TrackArtist[]
  albumArtists AlbumArtist[]
}

// ---------------------------------------
// Join Tables for music model
// ---------------------------------------

/**
 * Join table between Track and Artist.
 * Stores track-level artist credits and ordering.
 */
model TrackArtist {
  trackId  String
  artistId String

  /**
   * Order of appearance (0 = main artist, 1+ = feats, etc.)
   */
  order Int

  track  Track  @relation(fields: [trackId], references: [id], onDelete: Cascade)
  artist Artist @relation(fields: [artistId], references: [id], onDelete: Cascade)

  @@id([trackId, artistId])
  @@unique([trackId, order])
  @@index([trackId, order])
  @@index([artistId])
}

/**
 * Join table between Album and Artist.
 * Stores album-level artist credits and ordering.
 */
model AlbumArtist {
  albumId  String
  artistId String

  /**
   * Order of appearance (0 = main artist, 1+ = feats, etc.)
   */
  order Int

  album  Album  @relation(fields: [albumId], references: [id], onDelete: Cascade)
  artist Artist @relation(fields: [artistId], references: [id], onDelete: Cascade)

  @@id([albumId, artistId])
  @@unique([albumId, order])
  @@index([albumId, order])
  @@index([artistId])
}

// Source Files

/**
 * model SourceFile {
 * id        String   @id @default(cuid())
 * url       String   @unique
 * createdAt DateTime @default(now())
 * updatedAt DateTime @updatedAt
 * @@index([createdAt])
 * }
 */
